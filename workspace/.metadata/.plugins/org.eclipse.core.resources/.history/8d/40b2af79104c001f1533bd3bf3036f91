package net.minecraft.client.render.entity;

import java.util.Random;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.render.RenderBlocks;
import net.minecraft.client.render.RenderEngine;
import net.minecraft.client.render.Tessellator;
import net.minecraft.game.entity.Entity;
import net.minecraft.game.entity.misc.EntityItem;
import net.minecraft.game.item.ItemStack;
import net.minecraft.game.level.block.Block;
import org.lwjgl.opengl.GL11;
import util.MathHelper;

public final class RenderItem extends Render {
    private RenderBlocks renderBlocks = new RenderBlocks();
    private Random random = new Random();

    public RenderItem() {
        this.shadowSize = 0.15F;
        this.shadowOpaque = 12.0F / 16.0F;
    }

    public final void renderItemIntoGUI(RenderEngine var1, ItemStack var2, int var3, int var4) {
        if (var2 != null) {
            if (var2.itemID < 256 && Block.blocksList[var2.itemID].getRenderType() == 0) {
                int var9 = var2.itemID;
                RenderEngine.bindTexture(var1.getTexture("/terrain.png"));
                Block var8 = Block.blocksList[var9];
                GL11.glPushMatrix();
                GL11.glTranslatef((float) (var3 - 2), (float) (var4 + 3), 0.0F);
                GL11.glScalef(10.0F, 10.0F, 10.0F);
                GL11.glTranslatef(1.0F, 0.5F, 8.0F);
                GL11.glRotatef(210.0F, 1.0F, 0.0F, 0.0F);
                GL11.glRotatef(45.0F, 0.0F, 1.0F, 0.0F);
                GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
                this.renderBlocks.renderBlockOnInventory(var8);
                GL11.glPopMatrix();
            } else {
                render3DItem(var1, var2, var3, var4);
            }
        }
    }

    private void render3DItem(RenderEngine renderEngine, ItemStack itemStack, int x, int y) {
        GL11.glPushMatrix();
        GL11.glTranslatef((float) x, (float) y, 0.0F);
        GL11.glScalef(16.0F, 16.0F, 16.0F);
        GL11.glTranslatef(0.5F, 0.5F, 0.0F);

        int textureID;
        if (itemStack.itemID < 256) {
            textureID = renderEngine.getTexture("/terrain.png");
        } else {
            textureID = renderEngine.getTexture("/gui/items.png");
        }

        renderEngine.bindTexture(textureID);
        Tessellator tessellator = Tessellator.instance;

        int iconIndex = itemStack.getItem().getIconIndex();
        float minU = (float) (iconIndex % 16 * 16) / 256.0F;
        float maxU = (float) (iconIndex % 16 * 16 + 16) / 256.0F;
        float minV = (float) (iconIndex / 16 * 16) / 256.0F;
        float maxV = (float) (iconIndex / 16 * 16 + 16) / 256.0F;

        for (int i = 0; i < 8; ++i) {
            GL11.glPushMatrix();
            if (i > 0) {
                float xOffset = (random.nextFloat() * 2.0F - 1.0F) * 0.05F;
                float yOffset = (random.nextFloat() * 2.0F - 1.0F) * 0.05F;
                float zOffset = (random.nextFloat() * 2.0F - 1.0F) * 0.05F;
                GL11.glTranslatef(xOffset, yOffset, zOffset);
            }

            GL11.glRotatef(180.0F - renderManager.playerViewY, 0.0F, 1.0F, 0.0F);
            tessellator.startDrawingQuads();
            tessellator.setNormal(0.0F, 1.0F, 0.0F);
            tessellator.addVertexWithUV(-0.5F, -0.25F, 0.0F, minU, maxV);
            tessellator.addVertexWithUV(0.5F, -0.25F, 0.0F, maxU, maxV);
            tessellator.addVertexWithUV(0.5F, 0.75F, 0.0F, maxU, minV);
            tessellator.addVertexWithUV(-0.5F, 0.75F, 0.0F, minU, minV);
            tessellator.draw();
            GL11.glPopMatrix();
        }

        GL11.glPopMatrix();
    }

    public final void renderItemOverlayIntoGUI(FontRenderer fontRenderer, ItemStack itemStack, int x, int y) {
        if (itemStack != null) {
            if (itemStack.stackSize > 1) {
                String countText = "" + itemStack.stackSize;
                GL11.glDisable(GL11.GL_LIGHTING);
                GL11.glDisable(GL11.GL_DEPTH_TEST);
                fontRenderer.drawStringWithShadow(countText, x + 19 - 2 - fontRenderer.getStringWidth(countText), y + 6 + 3, 16777215);
                GL11.glEnable(GL11.GL_LIGHTING);
                GL11.glEnable(GL11.GL_DEPTH_TEST);
            }

            if (itemStack.itemDamage > 0) {
                int barWidth = 13 - itemStack.itemDamage * 13 / ItemStack.getMaxDamage();
                int barColor = 255 - itemStack.itemDamage * 255 / ItemStack.getMaxDamage();
                GL11.glDisable(GL11.GL_LIGHTING);
                GL11.glDisable(GL11.GL_DEPTH_TEST);
                GL11.glDisable(GL11.GL_TEXTURE_2D);
                Tessellator tessellator = Tessellator.instance;
                int borderColor = (255 - barColor) / 4 << 16 | 16128;
                barColor = (255 - barColor << 16) | (barColor << 8);
                renderQuad(tessellator, x + 2, y + 13, 13, 2, 0);
                renderQuad(tessellator, x + 2, y + 13, 12, 1, borderColor);
                renderQuad(tessellator, x + 2, y + 13, barWidth, 1, barColor);
                GL11.glEnable(GL11.GL_TEXTURE_2D);
                GL11.glEnable(GL11.GL_LIGHTING);
                GL11.glEnable(GL11.GL_DEPTH_TEST);
                GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
            }
        }
    }

    private static void renderQuad(Tessellator tessellator, int x, int y, int width, int height, int color) {
        tessellator.startDrawingQuads();
        tessellator.setColorOpaque_I(color);
        tessellator.addVertex((float) x, (float) y, 0.0F);
        tessellator.addVertex((float) x, (float) (y + height), 0.0F);
        tessellator.addVertex((float) (x + width), (float) (y + height), 0.0F);
        tessellator.addVertex((float) (x + width), (float) y, 0.0F);
        tessellator.draw();
    }

    public final void doRender(Entity entity, float x, float y, float z, float yaw, float partialTicks) {
        EntityItem entityItem = (EntityItem) entity;
        ItemStack itemStack = entityItem.item;
        GL11.glPushMatrix();
        float hoverOffset = MathHelper.sin(((float) entityItem.age + partialTicks) / 10.0F + entityItem.hoverStart) * 0.1F + 0.1F;
        float rotation = (((float) entityItem.age + partialTicks) / 20.0F + entityItem.hoverStart) * (180.0F / (float) Math.PI);
        int renderCount = 1;
        if (entityItem.item.stackSize > 1) {
            renderCount = 2;
        }

        if (entityItem.item.stackSize > 5) {
            renderCount = 3;
        }

        if (entityItem.item.stackSize > 20) {
            renderCount = 4;
        }

        GL11.glTranslatef(x, y + hoverOffset, z);
        GL11.glEnable(GL11.GL_NORMALIZE);
        GL11.glRotatef(rotation, 0.0F, 1.0F, 0.0F);
        GL11.glScalef(0.5F, 0.5F, 0.5F);

        if (itemStack.itemID < 256 && Block.blocksList[itemStack.itemID].getRenderType() == 0) {
            render3DItemBlocks(itemStack, renderCount);
        } else {
            render3DItem(renderManager.renderEngine, itemStack, 0, 0);
        }

        GL11.glDisable(GL11.GL_NORMALIZE);
        GL11.glPopMatrix();
    }

    private void render3DItemBlocks(ItemStack itemStack, int renderCount) {
        GL11.glScalef(0.5F, 0.5F, 0.5F);
        for (int i = 0; i < renderCount; ++i) {
            GL11.glPushMatrix();
            if (i > 0) {
                float xOffset = (random.nextFloat() * 2.0F - 1.0F) * 0.3F;
                float yOffset = (random.nextFloat() * 2.0F - 1.0F) * 0.3F;
                float zOffset = (random.nextFloat() * 2.0F - 1.0F) * 0.3F;
                GL11.glTranslatef(xOffset, yOffset, zOffset);
            }
            this.renderBlocks.renderBlockOnInventory(Block.blocksList[itemStack.itemID]);
            GL11.glPopMatrix();
        }
    }
}
