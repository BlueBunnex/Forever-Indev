package net.minecraft.client.render.entity;

import java.util.Random;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.render.RenderBlocks;
import net.minecraft.client.render.RenderEngine;
import net.minecraft.client.render.Tessellator;
import net.minecraft.game.entity.Entity;
import net.minecraft.game.entity.misc.EntityItem;
import net.minecraft.game.item.ItemStack;
import net.minecraft.game.level.block.Block;
import org.lwjgl.opengl.GL11;
import util.MathHelper;

public final class RenderItem extends Render {
    private RenderBlocks renderBlocks = new RenderBlocks();
    private Random random = new Random();

    public RenderItem() {
        this.shadowSize = 0.15F;
        this.shadowOpaque = 12.0F / 16.0F;
    }

    public final void renderItemIntoGUI(RenderEngine renderEngine, ItemStack itemStack, int x, int y) {
        if (itemStack != null) {
            if (itemStack.itemID < 256 && Block.blocksList[itemStack.itemID].getRenderType() == 0) {
                // Render block as item in GUI
                int blockID = itemStack.itemID;
                renderEngine.bindTexture(renderEngine.getTexture("/terrain.png"));
                Block block = Block.blocksList[blockID];
                GL11.glPushMatrix();
                GL11.glTranslatef((float) (x - 2), (float) (y + 3), 0.0F);
                GL11.glScalef(10.0F, 10.0F, 10.0F);
                GL11.glTranslatef(1.0F, 0.5F, 8.0F);
                GL11.glRotatef(210.0F, 1.0F, 0.0F, 0.0F);
                GL11.glRotatef(45.0F, 0.0F, 1.0F, 0.0F);
                GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
                this.renderBlocks.renderBlockOnInventory(block);
                GL11.glPopMatrix();
            } else {
                // Render item icon as 3D item in GUI
                if (itemStack.getItem().getIconIndex() >= 0) {
                    GL11.glDisable(GL11.GL_LIGHTING);
                    GL11.glEnable(GL11.GL_DEPTH_TEST); // Enable depth testing
                    if (itemStack.itemID < 256) {
                        renderEngine.bindTexture(renderEngine.getTexture("/terrain.png"));
                    } else {
                        renderEngine.bindTexture(renderEngine.getTexture("/gui/items.png"));
                    }

                    int xPos = x;
                    int yPos = y;
                    int iconX = itemStack.getItem().getIconIndex() % 16 << 4;
                    int iconY = itemStack.getItem().getIconIndex() / 16 << 4;
                    int tempX = xPos;
                    int tempY = yPos;
                    int textureX = iconX;
                    int textureY = iconY;

                    Tessellator tessellator = Tessellator.instance;
                    tessellator.startDrawingQuads();
                    
                    // Adjust vertex positions for 3D effect
                    tessellator.addVertexWithUV((float) tempX, (float) (tempY + 16), 0.0F, (float) textureX * 0.00390625F, (float) (textureY + 16) * 0.00390625F);
                    tessellator.addVertexWithUV((float) (tempX + 16), (float) (tempY + 16), 0.0F, (float) (textureX + 16) * 0.00390625F, (float) (textureY + 16) * 0.00390625F);
                    tessellator.addVertexWithUV((float) (tempX + 16), (float) tempY, 0.0F, (float) (textureX + 16) * 0.00390625F, (float) textureY * 0.00390625F);
                    tessellator.addVertexWithUV((float) tempX, (float) tempY, 0.0F, (float) textureX * 0.00390625F, (float) textureY * 0.00390625F);
                    
                    tessellator.draw();
                    GL11.glEnable(GL11.GL_LIGHTING);
                }
            }
        }
    }

    public final void renderItemOverlayIntoGUI(FontRenderer fontRenderer, ItemStack itemStack, int x, int y) {
        if (itemStack != null) {
            if (itemStack.stackSize > 1) {
                String stackSize = "" + itemStack.stackSize;
                GL11.glDisable(GL11.GL_LIGHTING);
                GL11.glDisable(GL11.GL_DEPTH_TEST);
                fontRenderer.drawStringWithShadow(stackSize, x + 19 - 2 - fontRenderer.getStringWidth(stackSize), y + 6 + 3, 16777215);
                GL11.glEnable(GL11.GL_LIGHTING);
                GL11.glEnable(GL11.GL_DEPTH_TEST);
            }

            if (itemStack.itemDamage > 0) {
                int maxDamage = 13 - itemStack.itemDamage * 13 / itemStack.isItemStackDamageable();
                int damageColor = 255 - itemStack.itemDamage * 255 / itemStack.isItemStackDamageable();
                GL11.glDisable(GL11.GL_LIGHTING);
                GL11.glDisable(GL11.GL_DEPTH_TEST);
                GL11.glDisable(GL11.GL_TEXTURE_2D);
                Tessellator tessellator = Tessellator.instance;
                int color = 255 - damageColor << 16 | damageColor << 8;
                damageColor = (255 - damageColor) / 4 << 16 | 16128;
                renderQuad(tessellator, x + 2, y + 13, 13, 2, 0);
                renderQuad(tessellator, x + 2, y + 13, 12, 1, damageColor);
                renderQuad(tessellator, x + 2, y + 13, maxDamage, 1, color);
                GL11.glEnable(GL11.GL_TEXTURE_2D);
                GL11.glEnable(GL11.GL_LIGHTING);
                GL11.glEnable(GL11.GL_DEPTH_TEST);
                GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
            }
        }
    }

    private static void renderQuad(Tessellator tessellator, int x, int y, int width, int height, int color) {
        tessellator.startDrawingQuads();
        tessellator.setColorOpaque_I(color);
        tessellator.addVertex((float) x, (float) y, 0.0F);
        tessellator.addVertex((float) x, (float) (y + height), 0.0F);
        tessellator.addVertex((float) (x + width), (float) (y + height), 0.0F);
        tessellator.addVertex((float) (x + width), (float) y, 0.0F);
        tessellator.draw();
    }

    public final void doRender(Entity entity, float x, float y, float z, float yaw, float pitch) {
        EntityItem entityItem = (EntityItem) entity;
        this.random.setSeed(187L);
        ItemStack itemStack = entityItem.item;
        GL11.glPushMatrix();
        float hover = MathHelper.sin(((float) entityItem.age + pitch) / 10.0F + entityItem.hoverStart) * 0.1F + 0.1F;
        float rotation = (((float) entityItem.age + pitch) / 20.0F + entityItem.hoverStart) * (180.0F / (float) Math.PI);
        byte stackSizeLevel = 1;
        if (entityItem.item.stackSize > 1) {
            stackSizeLevel = 2;
        }
        if (entityItem.item.stackSize > 5) {
            stackSizeLevel = 3;
        }
        if (entityItem.item.stackSize > 20) {
            stackSizeLevel = 4;
        }

        GL11.glTranslatef(x, y + hover, z);
        GL11.glEnable(GL11.GL_NORMALIZE);

        if (itemStack.itemID < 256 && Block.blocksList[itemStack.itemID].getRenderType() == 0) {
            GL11.glRotatef(rotation, 0.0F, 1.0F, 0.0F);
            this.loadTexture("/terrain.png");
            float scale = 0.25F;
            if (!Block.blocksList[itemStack.itemID].renderAsNormalBlock() && itemStack.itemID != Block.slabHalf.blockID) {
                scale = 0.5F;
            }
            GL11.glScalef(scale, scale, scale);

            for (int i = 0; i < stackSizeLevel; ++i) {
                GL11.glPushMatrix();
                if (i > 0) {
                    float offsetX = (this.random.nextFloat() * 2.0F - 1.0F) * 0.2F / scale;
                    float offsetY = (this.random.nextFloat() * 2.0F - 1.0F) * 0.2F / scale;
                    float offsetZ = (this.random.nextFloat() * 2.0F - 1.0F) * 0.2F / scale;
                    GL11.glTranslatef(offsetX, offsetY, offsetZ);
                }
                this.renderBlocks.renderBlockOnInventory(Block.blocksList[itemStack.itemID]);
                GL11.glPopMatrix();
            }
        } else {
            GL11.glScalef(0.5F, 0.5F, 0.5F);
            int iconIndex = itemStack.getItem().getIconIndex();
            if (itemStack.itemID < 256) {
                this.loadTexture("/terrain.png");
            } else {
                this.loadTexture("/gui/items.png");
            }

            Tessellator tessellator = Tessellator.instance;
            float u0 = (float) (iconIndex % 16 << 4) / 256.0F;
            float u1 = (float) ((iconIndex % 16 << 4) + 16) / 256.0F;
            float v0 = (float) (iconIndex / 16 << 4) / 256.0F;
            float v1 = (float) ((iconIndex / 16 << 4) + 16) / 256.0F;

            for (int j = 0; j < stackSizeLevel; ++j) {
                GL11.glPushMatrix();
                if (j > 0) {
                    float offsetX = (this.random.nextFloat() * 2.0F - 1.0F) * 0.3F;
                    float offsetY = (this.random.nextFloat() * 2.0F - 1.0F) * 0.3F;
                    float offsetZ = (this.random.nextFloat() * 2.0F - 1.0F) * 0.3F;
                    GL11.glTranslatef(offsetX, offsetY, offsetZ);
                }

                GL11.glRotatef(180.0F - this.renderManager.playerViewY, 0.0F, 1.0F, 0.0F);
                tessellator.startDrawingQuads();
                Tessellator.setNormal(0.0F, 1.0F, 0.0F);
                tessellator.addVertexWithUV(-0.5F, -0.25F, 0.0F, u0, v1);
                tessellator.addVertexWithUV(0.5F, -0.25F, 0.0F, u1, v1);
                tessellator.addVertexWithUV(0.5F, 12.0F / 16.0F, 0.0F, u1, v0);
                tessellator.addVertexWithUV(-0.5F, 12.0F / 16.0F, 0.0F, u0, v0);
                tessellator.draw();
                GL11.glPopMatrix();
            }
        }

        GL11.glDisable(GL11.GL_NORMALIZE);
        GL11.glPopMatrix();
    }
}
