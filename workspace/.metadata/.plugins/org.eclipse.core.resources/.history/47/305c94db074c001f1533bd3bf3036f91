package net.minecraft.client.gui;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Properties;
import net.minecraft.client.PlayerLoader;
import net.minecraft.game.level.World;

public class GuiLoadLevel extends GuiScreen {

	private GuiScreen parent;
	private String[] slots = new String[5];
	private String statusMessage = "Use OfflineDatSave addon to save locally";
	protected String title = "Save/Load Level";
	private File selectedFile;

	private static final int SLOT_COUNT = 5;
	private static final String SLOT_FILENAME = "slot.properties";

	public GuiLoadLevel(GuiScreen parent) {
		this.parent = parent;
		loadSlotNames();
	}

	private void loadSlotNames() {
		Properties props = new Properties();
		File file = new File(this.mc.mcDataDir, SLOT_FILENAME);
		if (file.exists()) {
			try (FileInputStream in = new FileInputStream(file)) {
				props.load(in);
				for (int i = 0; i < SLOT_COUNT; i++) {
					slots[i] = props.getProperty("slot" + i, "Empty Slot " + (i + 1));
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		} else {
			for (int i = 0; i < SLOT_COUNT; i++) {
				slots[i] = "Empty Slot " + (i + 1);
			}
		}
	}

	private void saveSlotNames() {
		Properties props = new Properties();
		for (int i = 0; i < SLOT_COUNT; i++) {
			props.setProperty("slot" + i, slots[i]);
		}
		try (FileOutputStream out = new FileOutputStream(new File(this.mc.mcDataDir, SLOT_FILENAME))) {
			props.store(out, null);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	@Override
	public void updateScreen() {
		if (this.selectedFile != null) {
			this.saveToSlot(this.selectedFile);
			this.selectedFile = null;
			this.mc.displayGuiScreen(null);
		}
	}

	@Override
	public void initGui() {
		int buttonWidth = 200;
		int buttonHeight = 20;
		int verticalSpacing = 24;
		int baseY = this.height / 4;

		for (int i = 0; i < SLOT_COUNT; i++) {
			this.controlList.add(new GuiButton(i, this.width / 2 - buttonWidth / 2, baseY + i * verticalSpacing, buttonWidth, buttonHeight, slots[i]));
		}
		this.controlList.add(new GuiButton(SLOT_COUNT, this.width / 2 - buttonWidth / 2, baseY + SLOT_COUNT * verticalSpacing, buttonWidth, buttonHeight, "Save to Slot"));
		this.controlList.add(new GuiButton(SLOT_COUNT + 1, this.width / 2 - buttonWidth / 2, baseY + SLOT_COUNT * verticalSpacing + verticalSpacing, buttonWidth, buttonHeight, "Cancel"));
	}

	@Override
	protected final void actionPerformed(GuiButton button) {
		if (!button.enabled) return;

		if (button.id < SLOT_COUNT) {
			this.loadFromSlot(button.id);
		} else if (button.id == SLOT_COUNT) {
			FileDialog fileDialog = saveFileDialog();
			fileDialog.setVisible(true);
			String file = fileDialog.getFile();
			if (file != null) {
				this.selectedFile = new File(fileDialog.getDirectory(), file);
				this.saveToSlot(this.selectedFile);
			}
		} else if (button.id == SLOT_COUNT + 1) {
			this.mc.displayGuiScreen(this.parent);
		}
	}

	protected FileDialog saveFileDialog() {
		return new FileDialog((Dialog) null, "Save Level", FileDialog.SAVE);
	}

	protected void loadFromSlot(int slot) {
		File slotFile = new File(this.mc.mcDataDir, "slot" + slot + ".mclevel");
		if (slotFile.exists()) {
			try (FileInputStream in = new FileInputStream(slotFile)) {
				World world = (new PlayerLoader(this.mc, this.mc.loadingScreen)).load(in);
				this.mc.setLevel(world);
				this.mc.displayGuiScreen(null);
				this.mc.setIngameFocus();
			} catch (IOException e) {
				e.printStackTrace();
			}
		} else {
			this.statusMessage = "Slot " + (slot + 1) + " is empty!";
		}
	}

	protected void saveToSlot(File file) {
		for (int i = 0; i < SLOT_COUNT; i++) {
			if (slots[i].startsWith("Empty Slot")) {
				try (FileOutputStream out = new FileOutputStream(new File(this.mc.mcDataDir, "slot" + i + ".mclevel"))) {
					// Assuming we have a method saveWorld to save the current world to an output stream
					PlayerLoader.saveWorld(this.mc.theWorld, out);
					slots[i] = file.getName();
					this.updateSlotDisplay();
					this.saveSlotNames();
					this.statusMessage = "Saved to slot " + (i + 1);
					break;
				} catch (IOException e) {
					e.printStackTrace();
					this.statusMessage = "Failed to save!";
				}
			}
		}
	}

	private void updateSlotDisplay() {
		for (int i = 0; i < SLOT_COUNT; i++) {
			((GuiButton) this.controlList.get(i)).displayString = slots[i];
		}
	}

	@Override
	public final void drawScreen(int mouseX, int mouseY, float partialTicks) {
		this.drawDefaultBackground();
		drawCenteredString(this.fontRenderer, this.title, this.width / 2, 20, 0xFFFFFF);
		drawCenteredString(this.fontRenderer, this.statusMessage, this.width / 2, this.height / 2 - 4, 0xFFFFFF);
		super.drawScreen(mouseX, mouseY, partialTicks);
	}
}
